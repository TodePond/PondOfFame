const SAVE = (
"camera:x=565.31460413781,y=335.9193309828227,scale=0.3793721548678575;entities:;id=0,source=Plane.png,x=35395.02657785531,y=-8210.363826481114,z=0,scale=0.7490068389192478,rotation=-6.6599146053666;id=1,source=Dot.png,x=-1112.3802432363698,y=-199.2064959521112,z=-1,scale=0.23723231804219377,rotation=0;id=2,source=Dot.png,x=1665.0490357463407,y=868.948678081306,z=-1,scale=0.23723231804219377,rotation=0;id=3,source=Dot.png,x=3951.503817565211,y=3853.120357958002,z=-1,scale=0.23723231804219377,rotation=0;id=4,source=Dot.png,x=8443.298322196122,y=984.9797339048472,z=-1,scale=0.23723231804219377,rotation=0;id=5,source=Dot.png,x=11524.57112769105,y=-1853.7435091050681,z=-1,scale=0.23723231804219377,rotation=0;id=6,source=Dot.png,x=17079.13060912087,y=-5213.28582158229,z=-1,scale=0.23723231804219377,rotation=0;id=7,source=Dot.png,x=19100.944663096976,y=2198.4429956227204,z=-1,scale=0.23723231804219377,rotation=0;id=8,source=Dot.png,x=27051.705842472602,y=-10345.641928134315,z=-1,scale=0.23723231804219377,rotation=0;id=9,source=Dot.png,x=31486.94416267035,y=-5827.459514524549,z=-1,scale=0.23723231804219377,rotation=0;id=12,source=Pond1.png,x=-1177.564913789029,y=-308.06717943119634,z=-5,scale=1.5786840794092463,rotation=118.49435449032491;id=13,source=Tree1.png,x=1566.7160883683457,y=589.9548254658055,z=-2,scale=1,rotation=-19.821886681411325;id=14,source=Tree1.png,x=1683.9372098427204,y=1195.1038067708375,z=0,scale=1,rotation=193.8908518821929;id=15,source=Tree1.png,x=2158.303498829988,y=745.1727773789781,z=0,scale=1.2762815625000004,rotation=38.92045649847701;id=16,source=Grass.png,x=3549.33542198885,y=3979.187271179728,z=0,scale=0.5376616644748713,rotation=-0.5122141295386463;id=17,source=Grass.png,x=3734.879718899445,y=3511.988121907439,z=0,scale=0.5403600876626365,rotation=-0.01592824771934131;id=18,source=Grass.png,x=4090.8380092510743,y=4150.862043331952,z=0,scale=0.6844921500592587,rotation=2.526193640019155;id=19,source=Grass.png,x=4196.728438948907,y=3587.9765559983357,z=0,scale=0.5927719850835456,rotation=1.9790791069477078;id=20,source=Pond2.png,x=7844.286906563942,y=1926.1437304119656,z=0,scale=2.4706590755578075,rotation=57.29262194564339;id=23,source=Pond1.png,x=8303.566530204793,y=1917.2091952872597,z=-5,scale=2.4490571565036325,rotation=111.04075932032961;id=21,source=Flower.png,x=9156.910460719591,y=1178.630596067073,z=1,scale=0.9900374375390625,rotation=-25.042312367405717;id=22,source=Flower.png,x=8092.0429376626835,y=698.4667477866519,z=1,scale=0.4357418792245978,rotation=-175.21671296022456;id=24,source=Flower.png,x=7878.25810605322,y=792.2743135950054,z=-2,scale=0.7277684917501196,rotation=-42.977137788908315;id=25,source=Grass.png,x=9011.760236873515,y=1134.6695768586892,z=-1,scale=1.4265764604953062,rotation=0;id=26,source=Grass.png,x=7937.677272059106,y=756.6268855464346,z=-3,scale=1.3383915334866219,rotation=0;id=27,source=Grass2.png,x=-1511.129012208867,y=-19.35294342198506,z=0,scale=0.5949894263083894,rotation=0;id=29,source=Grass2.png,x=-961.5828566403193,y=-691.720850784766,z=0,scale=0.4144645489046406,rotation=-0.20119743305977777;id=28,source=Grass2Flip.png,x=-950.7597037937785,y=-673.2513675962815,z=0,scale=0.35848592240854177,rotation=0;id=32,source=Grass.png,x=-957.9714445934276,y=-630.781366754072,z=0,scale=0.10935880111994853,rotation=17.30812307485352;id=33,source=Grass2Flip.png,x=4264.298496718716,y=3536.7656630861857,z=0,scale=0.5688000922764596,rotation=0;id=35,source=Grass2.png,x=3635.7109245539395,y=3519.248625932222,z=0,scale=0.3131749905703722,rotation=0;id=36,source=PondPurple1.png,x=11541.866994520096,y=-1921.006812210499,z=-2,scale=2.406619233691086,rotation=-34.67264739369941;id=34,source=Grass2.png,x=4026.4375225345593,y=4078.391860973453,z=0,scale=0.39969946630107756,rotation=0;id=37,source=Grass2Flip.png,x=3678.2085997477907,y=3972.553383512607,z=0,scale=0.35848592240854177,rotation=0;id=30,source=Grass.png,x=12070.449629024135,y=-1341.5503761828793,z=0,scale=0.7565439553286544,rotation=1.9790791069477078;id=31,source=Grass2Flip.png,x=12138.019686793945,y=-1392.761269095029,z=0,scale=0.7259490705207442,rotation=0;id=38,source=Tree1.png,x=16676.750848102427,y=-5622.5515776926595,z=0,scale=1.628894626777442,rotation=38.92045649847701;id=39,source=Tree1.png,x=16839.242768167212,y=-4824.130014816445,z=0,scale=1.1576250000000001,rotation=193.8908518821929;id=40,source=Tree1.png,x=17868.37611061313,y=-5335.460417666973,z=0,scale=1.3400956406250004,rotation=193.8908518821929;id=41,source=Banana.png,x=16666.65802714222,y=-5737.568257677025,z=0,scale=0.3972143184582181,rotation=162.62724209309116;id=42,source=Banana.png,x=17871.10373182547,y=-5092.935345311344,z=0,scale=0.3972143184582181,rotation=184.83088422281057;id=43,source=Banana.png,x=16909.809037946827,y=-5963.755244472004,z=0,scale=0.3972143184582181,rotation=329.6766863000335;id=44,source=Banana.png,x=16875.880989927573,y=-4680.144094410511,z=0,scale=0.3972143184582181,rotation=361.36010372959726;id=45,source=Dino.png,x=19378.64837676652,y=3452.846466818525,z=1,scale=1.7103393581163142,rotation=0;id=46,source=Dino2.png,x=19338.254046939044,y=1.5403443135897135,z=0,scale=1.9799315994393987,rotation=0;id=47,source=Dino.png,x=19555.725393547178,y=778.6686938840918,z=0,scale=1.7103393581163142,rotation=0;id=48,source=Dino.png,x=17755.388523147794,y=1401.125590564721,z=0,scale=1.7103393581163142,rotation=0;id=49,source=Dino2.png,x=18610.458290820145,y=2903.1471088402136,z=0,scale=2.0582167275721797,rotation=0;id=50,source=Dino.png,x=20806.621137989303,y=2979.8573294527287,z=0,scale=1.7103393581163142,rotation=0;id=51,source=Dino2.png,x=21345.505357788043,y=2619.694228029591,z=-1,scale=1.9799315994393987,rotation=0;id=52,source=Dino.png,x=21997.488662875287,y=955.059308272014,z=0,scale=1.6890667454431016,rotation=0;id=53,source=Rainbow.png,x=27255.982268698735,y=-11635.608284440239,z=0,scale=2.785962590401644,rotation=0;id=54,source=Cloud.png,x=28256.296572985022,y=-10900.401355570577,z=0,scale=1.5513282159785162,rotation=0;id=55,source=CloudFlip.png,x=26202.70630274263,y=-10916.320659991059,z=0,scale=1.628894626777442,rotation=0;id=56,source=Stone1.png,x=31962.012997458267,y=-5160.932836658841,z=0,scale=1,rotation=0.3308808567433968;id=57,source=Stone2.png,x=31731.57779157262,y=-6608.427306758083,z=0,scale=1,rotation=2.6002390595317966;id=58,source=Stone1.png,x=30452.699747734416,y=-5554.546460060139,z=0,scale=1,rotation=1.1115778698433467;id=59,source=Stone2.png,x=32002.146353246415,y=-6899.808834714477,z=0,scale=0.8005453409251319,rotation=89.7929991606716;id=60,source=Stone2.png,x=32342.091469195548,y=-6615.364962185617,z=0,scale=1,rotation=2.6002390595317966;id=61,source=Stone2.png,x=32568.226034084433,y=-5570.7488069644605,z=0,scale=1,rotation=2.6002390595317966;id=62,source=Stone2.png,x=31122.98373487356,y=-5073.9257099906745,z=0,scale=1,rotation=2.6002390595317966;id=63,source=Stone1.png,x=30986.89921565447,y=-6421.753388501792,z=0,scale=1,rotation=1.1115778698433467;id=10,source=Dot.png,x=36297.198792650626,y=-7699.67126950078,z=-1,scale=0.23723231804219377,rotation=0;id=11,source=Dot.png,x=39074.628071633415,y=-6631.51609546736,z=-1,scale=0.23723231804219377,rotation=0;id=64,source=Pond1.png,x=36232.01412209797,y=-7808.531952979868,z=-5,scale=1.5786840794092463,rotation=118.49435449032491;id=65,source=Tree1.png,x=38976.29512425542,y=-6910.50994808286,z=-2,scale=1,rotation=-19.821886681411325;id=66,source=Tree1.png,x=39093.5162457298,y=-6305.360966777827,z=-2,scale=1,rotation=193.8908518821929;id=67,source=Tree1.png,x=39567.88253471708,y=-6755.291996169687,z=-3,scale=1.2762815625000004,rotation=38.92045649847701;id=68,source=Grass2.png,x=35898.45002367812,y=-7519.817716970652,z=0,scale=0.5949894263083894,rotation=0;id=69,source=Grass2.png,x=36447.99617924668,y=-8192.185624333439,z=0,scale=0.4144645489046406,rotation=-0.20119743305977777;id=70,source=Grass2Flip.png,x=36458.81933209322,y=-8173.716141144955,z=0,scale=0.35848592240854177,rotation=0;id=71,source=Grass.png,x=36451.60759129357,y=-8131.246140302745,z=0,scale=0.10935880111994853,rotation=17.30812307485352;id=72,source=Dot.png,x=41439.30095708641,y=-3344.2110846089276,z=-1,scale=0.23723231804219377,rotation=0;id=74,source=Cloud.png,x=36685.073765452995,y=-18591.832852672953,z=0,scale=1.5513282159785162,rotation=0;routes:;id=0,start=1,end=2,length=5000,type=snake,flip=true,slope=0.4;id=1,start=2,end=3,length=5000,type=snake,flip=true,slope=0.1;id=2,start=3,end=4,length=5000,type=single,flip=true,slope=0.1;id=3,start=4,end=5,length=5000,type=single,flip=false,slope=0.2;id=4,start=5,end=6,length=5000,type=snake,flip=true,slope=0.3;id=5,start=6,end=7,length=5000,type=snake,flip=true,slope=0.2;id=6,start=7,end=8,length=5000,type=snake,flip=true,slope=0.2;id=7,start=8,end=9,length=5000,type=snake,flip=true,slope=0.1;id=8,start=9,end=10,length=5000,type=snake,flip=true,slope=0.3;id=9,start=10,end=11,length=5000,type=snake,flip=true,slope=0.4;id=10,start=11,end=72,length=5000,type=snake,flip=true,slope=0.1;id=11,start=10,end=74,length=5000,type=snake,flip=false,slope=0.5"
)

const stage = Stage.make()
const {canvas, context} = stage

const camera = {x: 0, y: 0, scale: 1}
const entities = new Map()
const freeEntityIds = new Set()
const layers = new Map()
const routes = new Map()
const freeRouteIds = new Set()

const selectedEntities = new Set()
const selectionBoxStart = [undefined, undefined]

const imageCache = new Map()

// Make an entity AND THEN place it on the map
const createEntity = (...args) => {
    const entity = makeEntity(...args)
    registerEntity(entity)
    return entity
}

// Get an entity id that is free to use (note: remember to remove it from the freeEntityIds list if you use it)
const getNewId = () => {
	findFreeEntityIds()
    if (freeEntityIds.size > 0) {
		return freeEntityIds.values().next().value
	}
    else return entities.size
}

// Place an entity on the map
const registerEntity = (entity) => {
    const id = getNewId()
	loadEntity(entity, id)
    return id
}

// Place an entity on the map in a specific id
const loadEntity = (entity, id) => {
	entity.id = id
	entities.set(id, entity)
	freeEntityIds.delete(id)
	const {z} = entity
	if (layers.get(z) === undefined) {
		layers.set(z, new Map())
	}
	const layer = layers.get(z)
	layer.set(id, entity)
}

const moveLayer = (entity, dz) => {
	const z = entity.z
	const layer = layers.get(z)
	const id = entity.id
	layer.delete(id)
	const nz = z + dz
	if (layers.get(nz) === undefined) {
		layers.set(nz, new Map())
	}
	const newLayer = layers.get(nz)
	newLayer.set(id, entity)
	entity.z = nz
}

// Remove an entity from the map
const unregisterEntity = (id) => {
	const entity = entities.get(id)
    freeEntityIds.add(id)
    entities.delete(id)

	const {z} = entity
	const layer = layers.get(z)
	layer.delete(id)
	if (layer.size === 0) layer.delete(z)
}

// Remove all entities
const unregisterAllEntities = () => {
	freeEntityIds.clear()
	entities.clear()
	layers.clear()
}

// Make an entity object
const makeEntity = (source, {x = 0, y = 0, z = 0, scale = 1, rotation = 0} = {}) => {
    const image = getImage(source)
    const entity = {id: undefined, source, image, x, y, z, scale, rotation}
    return entity
}

// Get an image element (make one if needed)
const getImage = (source) => {
	if (source === undefined) return new Image()
    const cachedImage = imageCache.get(source)
    if (cachedImage !== undefined) return cachedImage
    const image = new Image()
    image.src = `../images/${source}`
    imageCache.set(source, image)
    return image
}

on.load(() => {
    document.body.appendChild(canvas)
    document.body.style["margin"] = "0"
    canvas.style["background-color"] = "rgb(23, 29, 40)"
    trigger("resize")
    load(SAVE)
    
})

on.resize(() => {
    canvas.width = innerWidth
    canvas.height = innerHeight
})

let clipboard = []
on.keydown(e => {
	if (e.key === "Delete") {
		for (const entity of selectedEntities) {
			unregisterEntity(entity.id)
		}
		return
	}
	if (e.key === "=") {
		for (const entity of selectedEntities.values()) {
			moveLayer(entity, 1)
		}
		return
	}
	if (e.key === "-") {
		for (const entity of selectedEntities.values()) {
			moveLayer(entity, -1)
		}
		return
	}
	if (e.ctrlKey) {
		if (e.key === "p" || e.key === "d") {
			e.preventDefault()
			for (const entity of selectedEntities.values()) {
				print("Entity:", entity)
			}
			return
		}
		if (e.key === "c") {
			clipboard = []
			for (const entity of selectedEntities.values()) {
				clipboard.push({...entity})
			}
			return
		}
		if (e.key === "v") {
			selectedEntities.clear()
			for (const entity of clipboard) {
				entity.d
				const paste = createEntity(entity.source, {...entity})
				paste.d
				selectedEntities.add(paste)
			}
			return
		}
	}
})

const findFreeEntityIds = () => {
	const founds = [false].repeat(entities.size)
	for (const entity of entities.values()) {
		founds[entity.id] = true
	}
	const frees = []
	for (const i in founds) {
		if (!founds[i]) frees.push(i.as(Number))
	}
	freeEntityIds.clear()
	for (const free of frees) {
		freeEntityIds.add(free)
	}
}

on.mousewheel((e) => {
	e.preventDefault()
    const {deltaY} = e

	if (e.altKey) {
		for (const entity of selectedEntities) {
			const zoom = (-deltaY / 100) * (entity.scale - entity.scale * (1 - 0.05))
			entity.scale += zoom
			if (entity.scale < 0) entity.scale = 0
		}
		updateHovers()
		return
	}

	const zoom = (-deltaY / 100) * (camera.scale - camera.scale * (1 - 0.05))
    camera.scale += zoom
	camera.x += zoom
	camera.y += zoom
	if (camera.scale < 0) camera.scale = 0
	updateHovers()
	
}, {passive: false})

on.mousemove(e => {
	updateHovers()
	if (Mouse.Middle) {
		const {movementX, movementY} = e
		camera.x -= movementX / camera.scale
		camera.y -= movementY / camera.scale
	}
	else if (Mouse.Right) {
		const {movementX, movementY} = e

		if (e.altKey) {
			const [mx, my] = Mouse.position
			for (const entity of selectedEntities) {
				const space = getEntitySpace(entity)
				const [cx, cy] = space.center
				const [dx, dy] = [cx - mx, cy - my]
				entity.rotation += (movementY * -dx) / 2000
				entity.rotation += (movementX * dy) / 2000
			}
			updateHovers()
			return
		}

		for (const entity of selectedEntities.values()) {
			entity.x += movementX / camera.scale
			entity.y += movementY / camera.scale
		}
	}
})

on.mousedown(e => {
	if (e.button === 0) {
		const [mx, my] = Mouse.position
		selectionBoxStart[0] = mx
		selectionBoxStart[1] = my
		
	}
})

on.mouseup(e => {
	if (e.button === 0) {
		const [mx, my] = Mouse.position
		const [sx, sy] = selectionBoxStart
		if (sx !== undefined || sy !== undefined) {
			let hits = selectedEntities
			if (sx === mx && sy === my) {
				const hit = getHit(mx, my)
				if (hit !== undefined) {
					if ((e.shiftKey || e.ctrlKey) && selectedEntities.has(hit)) {
						selectedEntities.delete(hit)
					}
					else hits = new Set([hit])
				}
				else hits = new Set()
			}
			else {
				hits = getSelects([sx, sy], [mx, my])
			}
			
			if (!e.shiftKey && !e.ctrlKey) {
				selectedEntities.clear()
			}

			for (const hit of hits.values()) {
				selectedEntities.add(hit)
			}
			
			selectionBoxStart[0] = undefined
			selectionBoxStart[1] = undefined
		}
	}
})

on.contextmenu(e => e.preventDefault())

const getHits = (x, y) => {
	const hits = new Set()
	for (const entity of entities.values()) {
		const space = getEntitySpace(entity)
		const isCollision = isSpaceCollision([x, y], space)
		if (isCollision) hits.add(entity)
	}
	return hits
}

const getHit = (x, y) => {
	const hits = getHits(x, y)
	const hit = findTopHit(hits)
	return hit
}

const findTopHit = (hits) => {
	const dummy = {z: -Infinity}
	const hit = [...hits.values()].reduce((a, b) => a.z > b.z? a : b, dummy)
	if (dummy === hit) return undefined
	return hit
}

const updateHovers = () => {
	const [mx, my] = Mouse.position
	const [sx, sy] = selectionBoxStart
	if (sx === undefined || sy === undefined) {
		const hits = getHits(mx, my)
		const hit = findTopHit(hits)
		for (const entity of entities.values()) {
			if (hit === entity) {
				entity.highlight = true
				entity.hover = true
			}
			else if (hits.has(entity)) {
				entity.hover = true
				entity.highlight = false
			}
			else {
				entity.hover = false
				entity.highlight = false
			}
		}
		return
	}
	else {
		const hits = getSelects([sx, sy], [mx, my])
		for (const entity of entities.values()) {
			if (hits.has(entity)) {
				entity.hover = true
				entity.highlight = true
			}
			else {
				entity.hover = false
				entity.highlight = false
			}
		}
	}
}

const getSelects = ([sx, sy], [mx, my]) => {
	const hits = new Set()
	const selection = {rotation: 0, position: [sx, sy], center: [sx+(mx-sx)/2, sy+(my-sy)/2], dimensions: [mx-sx, my-sy]}
	for (const entity of entities.values()) {
		const space = getEntitySpace(entity)
		// TODO: replace with actual rectangle collision detection (instead of faking it with point collision detection)
		if (isSpaceCollision([mx, my], space)) {
			hits.add(entity)
			continue
		}
		if (isSpaceCollision([sx, sy], space)) {
			hits.add(entity)
			continue
		}
		if (isSpaceCollision(selection.center, space)) {
			hits.add(entity)
			continue
		}
		if (isSpaceCollision(space.center, selection)) {
			hits.add(entity)
			continue
		}
		for (const corner of space.corners) {
			const rcorner = rotate(corner, space.center, space.rotation)
			if (isSpaceCollision(rcorner, selection)) {
				hits.add(entity)
				break
			}
		}
	}
	return hits
}

// https://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates
const rotate = ([x, y], [ox, oy], radians) => {
	const [dx, dy] = [x - ox, y - oy]
	const d = Math.sqrt(dx**2 + dy**2)
	const angle = Math.atan2(dy,dx)
	const [rx, ry] = [d * Math.cos(radians + angle), d * Math.sin(radians + angle)]
	return [ox + rx, oy + ry]
}

const isSpaceCollision = ([x, y], {rotation, position, center, dimensions}) => {
	if (rotation !== 0) {
		const [rx, ry] = rotate([x, y], center, -rotation)
		return isSpaceCollision([rx, ry], {rotation: 0, position, center, dimensions})
	}

	const [px, py] = position
	const [width, height] = dimensions

	const left = Math.min(px, px + width)
	const right = Math.max(px, px + width)
	const top = Math.min(py, py + height)
	const bottom = Math.max(py, py + height)

	if (x < left) return false
	if (x > right) return false
	if (y < top) return false
	if (y > bottom) return false
	return true
}

const toRadians = (degrees) => degrees * Math.PI / 180
const toDegrees = (radians) => radians * 180 / Math.PI

const makeSpace = ({scale = 1, x = 0, y = 0, width = 100, height = 100, rotation = 0}) => {

	const w = scale * width * camera.scale
	const h = scale * height * camera.scale
	const dimensions = [w, h]

	const px = canvas.width/2 + (x - camera.x - (width * scale)/2) * camera.scale
	const py = canvas.height/2 + (y - camera.y - (height * scale)/2) * camera.scale
	const position = [px, py]

	const cx = px + w/2
	const cy = py + h/2
	const center = [cx, cy]

	const corners = [
		[px, py],
		[px + w, py],
		[px + w, py + h],
		[px, py + h],
	]
	
	return {dimensions, position, center, corners, rotation: toRadians(rotation)}
}

const getEntitySpace = (entity) => {
	const image = entity.image
	const [width, height] = [image.width, image.height]
	const {scale, x, y, rotation} = entity
	return makeSpace({scale, x, y, width, height, rotation})
}

const getRouteId = () => {
	if (freeRouteIds.size > 0) {
		return freeRouteIds.values().next().value
	}
	return routes.size
}

const deleteRoute = (id) => {
	freeRouteIds.add(id)
	routes.delete(id)
}

const deleteAllRoutes = () => {
	freeRouteIds.clear()
	routes.clear()
}

const createRoute = (start, end, {id = getRouteId(), length = 5000, type = "snake", flip = false, slope = 0.5} = {}) => {
	const route = {start, end, length, type, flip, slope, id}
	freeRouteIds.delete(id)
	routes.set(id, route)
	return route
}

const getCurve = ([ax, ay], [bx, by], {length = 5000, type = "snake", flip = false, slope = 0.5} = {}) => {
	const [dx, dy] = [bx - ax, by - ay]
	let [ix, iy] = [dx / length, dy / length]
	if (flip) [ix, iy] = [iy, ix]
	const points = []
	const previous = [ax, ay]
	for (const i of (0).to(length-1)) {
		const [px, py] = previous
		let [jx, jy] = [ix, iy]
		if (type === "snake") {
			const easing = Math.min(i, length-1 - (i))
			const racing  = (length/2 - 1) - easing
			
			const ease = (easing * slope + racing) / (1 + slope)
			const race = (racing * slope + easing) / (1 + slope) 

			jx = ix * 2 * (race) / (length/2 - 1)
			jy = iy * 2 * (ease) / (length/2 - 1)
		}
		else if (type === "single") {

			const easing = length-1-i
			const racing = i

			const ease = (easing * slope + racing) / (1 + slope)
			const race = (racing * slope + easing) / (1 + slope) 

			jx = ix * 2 * ease / (length - 1)
			jy = iy * 2 * race / (length - 1)
		}
		if (flip) [jx, jy] = [jy, jx]
		const [x, y] = [px + jx, py + jy]
		points.push([x, y])
		previous[0] = x
		previous[1] = y
	}
	return points
}

let flightDelay = 0
const animateRoute = (route, plane = 0) => {
	const r = routes.get(route)
	const p = entities.get(plane)
	p.flying = true
	r.flightProgress = 0
	r.flying = true
	flightDelay = 200
}

const MAX_SPEED = 2
let prevRoute = undefined
let prevPlaneRot = undefined
stage.draw = () => {
    context.clearRect(0, 0, canvas.width, canvas.height);

	// Non-Plane Images
	const zs = [...layers.keys()].sort((a, b) => a - b)
	for (const z of zs) {
		const layer = layers.get(z)
		for (const entity of layer.values()) {

			if (entity.source === "Plane.png") continue

			const {image} = entity
			let {dimensions, rotation, center} = getEntitySpace(entity)

			const [width, height] = dimensions
			const [cx, cy] = center
			const [ox, oy] = [-width/2, -height/2]

			context.translate(cx, cy)
			context.rotate(rotation)
			context.drawImage(image, ox, oy, width, height)
			context.rotate(-rotation)
			context.translate(-(cx), -(cy))
		}
	}

	// Routes
	context.lineWidth = 26 * camera.scale
	context.setLineDash([100 * camera.scale, 50 * camera.scale])
	context.strokeStyle = "rgba(224, 224, 224)"

	let currentFrame = undefined

	for (const route of routes.values()) {
		const {start, end, slope, length, type, flip} = route
		const s = entities.get(start)
		const e = entities.get(end)
		if (s === undefined || e === undefined) {
			deleteRoute(route.id)
			continue
		}
		const [sx, sy] = getEntitySpace(s).center
		const [ex, ey] = getEntitySpace(e).center
		const curve = getCurve([sx, sy], [ex, ey], {slope, length, type, flip})

		context.beginPath()
		context.moveTo(sx, sy)
		let i = -1
		let previous = [sx, sy]
		for (const [x, y] of curve) {
			i++
			if (route.flying && i > route.flightProgress) {
				currentFrame = [previous, [x, y]]
				break
			}
			context.lineTo(x, y, ex, ey)
			previous = [x, y]
		}
		if (route.flying && flightDelay <= 0) {

			prevRoute = route
			const easing = Math.min(route.flightProgress + route.length / 8, (route.length-1) - (route.flightProgress)) * MAX_SPEED
			
			route.flightProgress += MAX_SPEED
			let penalty = MAX_SPEED - (easing / (route.length/3))
			penalty
			if (penalty > MAX_SPEED - MAX_SPEED * 0.06) penalty = MAX_SPEED - MAX_SPEED * 0.06
			route.flightProgress -= penalty
			
			if (route.flightProgress >= length) {
				route.flying = false
			}
		}
		flightDelay--
		context.stroke()
	}

	// Plane Images
	for (const z of zs) {
		const layer = layers.get(z)
		for (const entity of layer.values()) {

			if (entity.source !== "Plane.png") continue

			const {image} = entity
			let {dimensions, rotation, center} = getEntitySpace(entity)

			if (entity.flying) {
				
				if (currentFrame === undefined) {
					const end = entities.get(prevRoute.end)
					entity.x = end.x
					entity.y = end.y
					entity.rotation = toDegrees(prevPlaneRot)
					entity.flying = false
					let newSpace = getEntitySpace(entity)
					dimensions = newSpace.dimensions
					rotation = newSpace.rotation
					center = newSpace.center
				}
				else {
					const [prev, next] = currentFrame
					const [px, py] = prev
					const [nx, ny] = next
					const [dx, dy] = [nx - px, ny - py]
					rotation = Math.atan2(dy, dx)
					center = next
					prevPlaneRot = rotation
				}
			}

			const [width, height] = dimensions
			const [cx, cy] = center
			const [ox, oy] = [-width/2, -height/2]

			context.translate(cx, cy)
			context.rotate(rotation)
			context.drawImage(image, ox, oy, width, height)
			context.rotate(-rotation)
			context.translate(-(cx), -(cy))
		}
	}

	// Hovers
	context.lineWidth = 5 * camera.scale
	context.setLineDash([])
	for (const entity of entities.values()) {
        let {dimensions, rotation, center} = getEntitySpace(entity)
		
		if (entity.flying) {
			const [prev, next] = currentFrame
			const [px, py] = prev
			const [nx, ny] = next
			const [dx, dy] = [nx - px, ny - py]
			rotation = Math.atan2(dy, dx)
			center = next
		}

		const [width, height] = dimensions
		const [cx, cy] = center
		const [ox, oy] = [-width/2, -height/2]

		context.translate(cx, cy)
		context.rotate(rotation)
		
		if (entity.highlight) {
			context.fillStyle = "rgba(0, 128, 255, 25%)"
			context.fillRect(ox, oy, width, height)
		}

		if (selectedEntities.has(entity)) {
			context.strokeStyle = "rgba(0, 255, 128)"
			context.strokeRect(ox, oy, width, height)
		}
		else if (entity.hover) {
			context.strokeStyle = "rgba(0, 128, 255)"
			context.strokeRect(ox, oy, width, height)
		}

		context.rotate(-rotation)
		context.translate(-(cx), -(cy))

    }

	if (Mouse.Left) {
		const [sx, sy] = selectionBoxStart
		if (sx !== undefined && sy !== undefined) {
			const [mx, my] = Mouse.position
			context.strokeStyle = "rgba(0, 128, 255)"
			context.strokeRect(sx, sy, mx - sx, my - sy)
			context.fillStyle = "rgba(0, 128, 255, 25%)"
			context.fillRect(sx, sy, mx - sx, my - sy)
		}
	}
}

// Save the map state to a string
const save = () => {
    const lines = []
    lines.push(`camera:x=${camera.x},y=${camera.y},scale=${camera.scale}`)
    lines.push(`entities:`)
    for (const entity of entities.values()) {
        lines.push(`id=${entity.id},source=${entity.source},x=${entity.x},y=${entity.y},z=${entity.z},scale=${entity.scale},rotation=${entity.rotation}`)
    }
	lines.push(`routes:`)
    for (const route of routes.values()) {
        lines.push(`id=${route.id},start=${route.start},end=${route.end},length=${route.length},type=${route.type},flip=${route.flip},slope=${route.slope}`)
    }
    return lines.join(`;`)
}

const Load = MotherTode(`
	:: Camera ";" Entities ";" Routes EOF
	Camera (
		:: "camera:x=" Number ",y=" Number ",scale=" Number
		>> ([c, x, _1, y, _2, scale]) => {
			camera.x = x.output
			camera.y = y.output
			camera.scale = scale.output
		}
	)
	Entities :: "entities:" { Entity }
	Entity (
		:: ";id=" Number ",source=" String ",x=" Number ",y=" Number ",z=" Number ",scale=" Number ",rotation=" Number
		?? ([_1, id, _2, source, _3, x, _4, y, _5, z, _6, scale, _7, rotation]) => {
			const entity = makeEntity(source.output, {x: x.output, y: y.output, z: z.output, scale: scale.output, rotation: rotation.output})
			loadEntity(entity, id.output)
			return true
		}
	)
	Routes :: "routes:" { Route }
	Route (
		:: ";id=" Number ",start=" Number ",end=" Number ",length=" Number ",type=" String ",flip=" Boolean ",slope=" Number
		?? ([_1, id, _2, start, _3, end, _4, length, _5, type, _6, flip, _7, slope]) => {
			const route = createRoute(start.output, end.output, {id: id.output, length: length.output, type: type.output, flip: flip.output, slope: slope.output})
			return true
		}
	)
	String :: /[^,]/+
	Number :: "-"? /[0-9.]/+ >> (n) => n.output.as(Number)
	Boolean :: True | False
	True :: "true" >> true
	False :: "false" >> false
`)

// Load a map state
const load = (save) => {
	MotherTode.Term.resetCache()
	unregisterAllEntities()
	const result = Load(save)
	if (!result.success) {
		result.smartLog()
		result.log()
	}
	return result
}
